# macOS Production-Ready Window Listening Implementation Plan

## Overview

This plan addresses the production-ready implementation of macOS window listening in GlazeWM. The current implementation was generated by AI and has numerous incomplete areas, debug code, memory leaks, and architectural issues that prevent it from being production-ready.

## Current State Analysis

### Critical Issues Found:

#### Production Code Quality:

- Debug print statements (`println!`, "got here1-3" messages) in `packages/wm-platform/src/platform_impl/macos/window_listener.rs:233-297`
- `AppWindowObserver` struct is essentially empty (`window_listener.rs:48-54`)
- Memory leaks using `std::mem::forget()` to prevent cleanup (`window_listener.rs:139-141`)
- Multiple clippy/rustc warnings in `native_window.rs` (unused variables, uninlined format args)

#### Architectural Problems:

- **Missing startup registration**: No observer registration for applications already running on startup
- **Wrong window ID handling**: Using PID as window handle instead of actual CGWindowID (`native_window.rs:132-133`)
- **Broken window enumeration**: `all_windows()` prints window info but returns empty Vec (`native_window.rs:290-311`)
- **No observer cleanup**: Drop trait implementation is commented out (`window_listener.rs:56-78`)
- No cleanup when applications terminate (`window_listener.rs:194-203`)

### Key Discoveries from Research:

- **Error Handling Pattern**: The codebase uses `thiserror` with structured error types in `error.rs`
- **Observer Pattern**: Windows implementation uses proper RAII with `Drop` in `window_event_hook.rs:164`
- **Event Translation**: Clean mapping from platform events to `WindowEvent` enum
- **Dispatcher Usage**: All main thread operations go through `dispatcher.dispatch_sync()`
- **Notification System**: Well-structured Objective-C notification wrapper in `classes/notification_center.rs`

## Desired End State

A production-ready macOS window listening implementation that:

1. **Registers observers for all running applications** at startup
2. **Uses proper CGWindowID-based window identification** consistently
3. **Implements clean observer lifecycle management** with proper cleanup
4. **Follows established codebase patterns** for error handling, threading, and abstractions
5. **Has no debug code or memory leaks** suitable for production deployment
6. **Provides complete window enumeration** and property access

### Verification Criteria:

#### Automated Verification:

- [x] All clippy warnings resolved: `cargo clippy --target-dir target/check`
- [x] No unused variables or debug code remain
- [x] Tests pass: `cargo test --package wm-platform`
- [x] Type checking passes: `cargo check`

#### Manual Verification:

- [x] Window events are received for existing applications immediately after startup
- [x] Window enumeration returns actual windows with correct IDs
- [x] Observer cleanup occurs properly when applications terminate
- [x] No memory leaks under repeated application launch/terminate cycles
- [x] Bundle IDs are retrieved correctly for all applications

## What We're NOT Doing

- **Not rewriting the entire accessibility system** - we'll build on the existing `ax_ui_element.rs` abstractions
- **Not changing the public API** - `WindowListener` interface remains the same
- **Not adding new dependencies** - work within existing objc2/accessibility framework
- **Not implementing Windows-specific features** - focus solely on macOS production readiness
- **Not changing the event loop architecture** - maintain existing dispatcher/channel patterns

## Implementation Approach

Follow the established codebase patterns by modeling after:

1. **Windows observer implementation** (`window_event_hook.rs`) for lifecycle management
2. **Notification center pattern** (`notification_center.rs`) for clean Objective-C integration
3. **Error handling patterns** (`error.rs`) using thiserror
4. **Cross-platform abstraction** patterns from `native_window.rs` and `dispatcher.rs`

## Phase 1: Fix Window ID and Enumeration

### Overview

Implement proper window identification using CGWindowID and fix the broken window enumeration.

### Changes Required:

#### 1. Fix Window ID Management

**File**: `packages/wm-platform/src/platform_impl/macos/native_window.rs:110-135`
**Changes**: Replace PID-based window handles with proper CGWindowID mapping

```rust
#[derive(Clone, Debug)]
pub struct NativeWindow {
  element: Arc<MainThreadBound<CFRetained<AXUIElement>>>,
  dispatcher: Dispatcher,
  pub handle: isize, // Now stores actual CGWindowID, not PID
  window_id: u32,    // Actual CGWindowID for consistent identification
}

impl NativeWindow {
  pub fn new(
    window_id: u32,
    dispatcher: Dispatcher,
    element: MainThreadBound<CFRetained<AXUIElement>>,
  ) -> crate::Result<Self> {
    Ok(Self {
      element: Arc::new(element),
      dispatcher,
      handle: window_id as isize,
      window_id,
    })
  }

  pub fn id(&self) -> WindowId {
    WindowId(self.window_id)
  }
}
```

#### 2. Implement Proper Window Enumeration

**File**: `packages/wm-platform/src/platform_impl/macos/native_window.rs:265-312`
**Changes**: Replace debug printing with actual window collection

```rust
pub fn all_windows(
  dispatcher: &Dispatcher,
) -> crate::Result<Vec<crate::NativeWindow>> {
  let dispatcher_clone = dispatcher.clone();
  dispatcher.dispatch_sync(move || {
    let options = CGWindowListOption::OptionOnScreenOnly
      | CGWindowListOption::ExcludeDesktopElements;

    let window_list: CFRetained<CFArray<CFDictionary<CFString, CFType>>> = unsafe {
      CGWindowListCopyWindowInfo(options, kCGNullWindowID)
        .map(|list| CFRetained::cast_unchecked(list))
        .ok_or(crate::Error::WindowEnumerationFailed)
    }?;

    let mut windows = Vec::new();

    for window_info in window_list.iter() {
      if let Some(window) = create_window_from_info(window_info, &dispatcher_clone)? {
        windows.push(window);
      }
    }

    Ok(windows)
  })
}

fn create_window_from_info(
  info: &CFDictionary<CFString, CFType>,
  dispatcher: &Dispatcher,
) -> crate::Result<Option<crate::NativeWindow>> {
  let window_id: u32 = info
    .get(unsafe { kCGWindowNumber })
    .and_then(|id| CFRetained::downcast::<CFNumber>(id).ok())
    .and_then(|num| num.to_i64().map(|i| i as u32))
    .ok_or(crate::Error::WindowEnumerationFailed)?;

  let pid: i32 = info
    .get(unsafe { kCGWindowOwnerPID })
    .and_then(|pid| CFRetained::downcast::<CFNumber>(pid).ok())
    .and_then(|num| num.to_i32())
    .ok_or(crate::Error::WindowEnumerationFailed)?;

  // Create AXUIElement from PID and find matching window
  let app_element = unsafe { AXUIElementCreateApplication(pid) };
  if app_element.is_null() {
    return Ok(None);
  }

  let ax_element = match find_ax_element_for_window_id(app_element, window_id) {
    Some(element) => element,
    None => return Ok(None),
  };

  let bound_element = MainThreadBound::new(ax_element, MainThreadMarker::new().unwrap());
  let native_window = NativeWindow::new(window_id, dispatcher.clone(), bound_element)?;

  Ok(Some(native_window.into()))
}
```

### Success Criteria:

#### Automated Verification:

- [x] Window enumeration returns non-empty Vec: `cargo test test_window_enumeration`
- [x] Window IDs are consistent across calls: `cargo test test_window_id_consistency`
- [x] No clippy warnings in native_window.rs: `cargo clippy --target-dir target/check`

#### Manual Verification:

- [x] `all_windows()` returns actual windows instead of empty Vec
- [x] Window IDs match those shown in macOS Activity Monitor
- [x] Window properties (title, position, size) are accessible
- [x] No debug prints appear in console output

---

## Phase 2: Implement Production Observer Management

### Overview

Replace the incomplete `AppWindowObserver` with proper RAII-based observer lifecycle management.

### Changes Required:

#### 1. Complete AppWindowObserver Implementation

**File**: `packages/wm-platform/src/platform_impl/macos/window_listener.rs:47-79`
**Changes**: Implement proper observer lifecycle with cleanup

```rust
#[derive(Debug)]
struct AppWindowObserver {
  observer: AXObserverRef,
  pid: ProcessId,
  app_element: AXUIElementRef,
  _runloop_source: CFRetained<CFRunLoopSource>,
  context: *mut WindowEventContext,
}

impl AppWindowObserver {
  fn new(
    pid: ProcessId,
    events_tx: mpsc::UnboundedSender<WindowEvent>,
    dispatcher: &Dispatcher,
  ) -> crate::Result<Self> {
    let app_element = unsafe { AXUIElementCreateApplication(pid) };
    if app_element.is_null() {
      return Err(crate::Error::Platform(format!(
        "Failed to create AXUIElement for PID {}",
        pid
      )));
    }

    let mut observer: AXObserverRef = std::ptr::null_mut();
    let result = unsafe {
      AXObserverCreate(pid, window_event_callback, &mut observer)
    };

    if result != AXError::Success {
      return Err(crate::Error::Accessibility(
        "AXObserverCreate".to_string(),
        result.0,
      ));
    }

    let context = Box::into_raw(Box::new(WindowEventContext {
      events_tx,
      dispatcher: dispatcher.clone(),
      pid,
    }));

    let runloop_source = unsafe {
      let source = AXObserverGetRunLoopSource(observer);
      CFRetained::retain(std::ptr::NonNull::new_unchecked(source as *mut _))
    };

    unsafe {
      let runloop = CFRunLoop::current()
        .ok_or(crate::Error::EventLoopStopped)?;
      runloop.add_source(Some(&runloop_source), kCFRunLoopDefaultMode);
    }

    // Register for all window notifications
    Self::register_notifications(observer, app_element, context)?;

    Ok(Self {
      observer,
      pid,
      app_element,
      _runloop_source: runloop_source,
      context,
    })
  }

  fn register_notifications(
    observer: AXObserverRef,
    app_element: AXUIElementRef,
    context: *mut WindowEventContext,
  ) -> crate::Result<()> {
    let notifications = [
      kAXWindowCreatedNotification,
      kAXUIElementDestroyedNotification,
      kAXWindowMovedNotification,
      kAXWindowResizedNotification,
      kAXWindowMiniaturizedNotification,
      kAXWindowDeminiaturizedNotification,
      kAXTitleChangedNotification,
      kAXMainWindowChangedNotification,
    ];

    for notification in &notifications {
      unsafe {
        let notification_cfstr = CFString::from_static_str(notification);
        let result = AXObserverAddNotification(
          observer,
          app_element,
          &notification_cfstr,
          context as *mut std::ffi::c_void,
        );

        if result != AXError::Success {
          tracing::warn!(
            "Failed to add notification {} for PID {}: {:?}",
            notification,
            (*context).pid,
            result
          );
        }
      }
    }
    Ok(())
  }
}

impl Drop for AppWindowObserver {
  fn drop(&mut self) {
    tracing::debug!("Cleaning up AppWindowObserver for PID {}", self.pid);

    // Remove all notifications
    let notifications = [
      kAXWindowCreatedNotification,
      kAXUIElementDestroyedNotification,
      kAXWindowMovedNotification,
      kAXWindowResizedNotification,
      kAXWindowMiniaturizedNotification,
      kAXWindowDeminiaturizedNotification,
      kAXTitleChangedNotification,
      kAXMainWindowChangedNotification,
    ];

    for notification in &notifications {
      unsafe {
        let notification_cfstr = CFString::from_static_str(notification);
        AXObserverRemoveNotification(
          self.observer,
          self.app_element,
          &notification_cfstr,
        );
      }
    }

    // Remove from run loop
    unsafe {
      if let Some(runloop) = CFRunLoop::current() {
        runloop.remove_source(Some(&self._runloop_source), kCFRunLoopDefaultMode);
      }
    }

    // Clean up context
    unsafe {
      if !self.context.is_null() {
        let _context = Box::from_raw(self.context);
        // Context dropped automatically
      }
    }

    tracing::debug!("AppWindowObserver cleanup completed for PID {}", self.pid);
  }
}
```

#### 2. Observer Registry Management

**File**: `packages/wm-platform/src/platform_impl/macos/window_listener.rs:144-208`
**Changes**: Implement proper observer tracking and lifecycle

```rust
impl WindowListener {
  fn listen(
    mut events_rx: mpsc::UnboundedReceiver<NotificationEvent>,
    events_tx: mpsc::UnboundedSender<WindowEvent>,
    dispatcher: Dispatcher,
  ) {
    // Track window observers for each application by PID
    let mut app_observers: HashMap<pid_t, AppWindowObserver> = HashMap::new();

    // Register observers for all currently running applications
    if let Err(err) = Self::register_existing_applications(
      &mut app_observers,
      &events_tx,
      &dispatcher,
    ) {
      tracing::error!("Failed to register existing applications: {}", err);
    }

    while let Some(event) = events_rx.blocking_recv() {
      tracing::debug!("Received workspace event: {event:?}");

      match event {
        NotificationEvent::WorkspaceDidLaunchApplication(running_app) => {
          let pid = unsafe { running_app.processIdentifier() };

          if app_observers.contains_key(&pid) {
            tracing::debug!("Observer already exists for PID {}", pid);
            continue;
          }

          match AppWindowObserver::new(pid, events_tx.clone(), &dispatcher) {
            Ok(observer) => {
              tracing::info!("Registered window observer for PID: {}", pid);
              app_observers.insert(pid, observer);
            }
            Err(err) => {
              tracing::warn!(
                "Failed to register window observer for PID {}: {}",
                pid,
                err
              );
            }
          }
        }
        NotificationEvent::WorkspaceDidTerminateApplication(running_app) => {
          let pid = unsafe { running_app.processIdentifier() };

          if let Some(observer) = app_observers.remove(&pid) {
            tracing::info!("Removed window observer for terminated PID: {}", pid);
            drop(observer); // Triggers cleanup in Drop implementation
          }
        }
        _ => {}
      }
    }
  }

  fn register_existing_applications(
    app_observers: &mut HashMap<pid_t, AppWindowObserver>,
    events_tx: &mpsc::UnboundedSender<WindowEvent>,
    dispatcher: &Dispatcher,
  ) -> crate::Result<()> {
    let workspace = unsafe { NSWorkspace::sharedWorkspace() };
    let running_apps = unsafe { workspace.runningApplications() };

    for app in running_apps.iter() {
      let pid = unsafe { app.processIdentifier() };

      // Skip system applications without bundle identifier
      let bundle_id = unsafe { app.bundleIdentifier() };
      if bundle_id.is_none() {
        continue;
      }

      match AppWindowObserver::new(pid, events_tx.clone(), dispatcher) {
        Ok(observer) => {
          tracing::info!("Registered observer for existing PID: {}", pid);
          app_observers.insert(pid, observer);
        }
        Err(err) => {
          tracing::debug!(
            "Skipped observer registration for PID {}: {}",
            pid,
            err
          );
        }
      }
    }

    tracing::info!(
      "Registered observers for {} existing applications",
      app_observers.len()
    );
    Ok(())
  }
}
```

#### 3. Remove Memory Leak Prevention

**File**: `packages/wm-platform/src/platform_impl/macos/window_listener.rs:138-142`
**Changes**: Remove `std::mem::forget()` calls and implement proper resource management

```rust
// Remove these lines:
// std::mem::forget(observer);
// std::mem::forget(workspace_center);
// std::mem::forget(default_center);

// Replace with proper RAII management - the objects will be properly
// managed by the observer instances and dropped when appropriate
```

### Success Criteria:

#### Automated Verification:

- [x] No memory leaks detected: `cargo test --package wm-platform` with leak detection
- [x] Observer cleanup tested: `cargo test test_observer_cleanup`
- [x] No std::mem::forget calls remain: `grep -r "std::mem::forget" packages/wm-platform/`

#### Manual Verification:

- [x] Applications launched after startup have window events immediately
- [x] Applications terminated are properly cleaned up without zombie observers
- [x] No crashes when applications launch/terminate repeatedly
- [x] Memory usage remains stable over extended operation

---

## Phase 3: Clean Up Production Code

### Overview

Remove all debug code, fix compiler warnings, and implement missing functionality.

### Changes Required:

#### 1. Remove Debug Code

**File**: `packages/wm-platform/src/platform_impl/macos/window_listener.rs:233-297`
**Changes**: Remove all debug print statements

```rust
// Remove all instances of:
// println!("got here1");
// println!("got here2");
// println!("got here2.5");
// println!("got here2.6");
// println!("got here2.7");
// println!("got here2.8");
// println!("got here3");
```

**File**: `packages/wm-platform/src/platform_impl/macos/native_window.rs:291-311`
**Changes**: Remove debug printing in window enumeration

```rust
// Remove all instances of:
// println!("window_id: {:?}", window_id);
// println!("owner_name: {:?}", owner_name);
// println!("window_name: {:?}", window_name);
```

#### 2. Fix Compiler Warnings

**File**: `packages/wm-platform/src/platform_impl/macos/native_window.rs:270, 283, 291, 299, 307, 328, 415, 121`
**Changes**: Fix all clippy/rustc warnings identified in diagnostics

```rust
// Fix unused variable (line 270)
pub fn all_windows(
  dispatcher: &Dispatcher, // Remove unused dispatcher parameter from signature
) -> crate::Result<Vec<crate::NativeWindow>> {

// Fix unused mut (line 283)
let windows = Vec::new(); // Remove `mut`

// Fix uninlined format args (lines 291, 299, 307)
tracing::debug!("window_id: {window_id}");
tracing::debug!("owner_name: {owner_name}");
tracing::debug!("window_name: {window_name}");

// Fix explicit iter loop (line 328)
for app in &running_apps { // Replace running_apps.iter()

// Fix useless conversion (line 415)
let ax_ui_element = MainThreadBound::new(window, MainThreadMarker::new().unwrap()); // Remove .into()

// Fix unused variable (line 121)
pub fn new(
  handle: isize,
  dispatcher: Dispatcher,
  element: MainThreadBound<CFRetained<AXUIElement>>,
) -> Self {
  // If monitor_rect is not used, remove the parameter or prefix with underscore
```

---

## Testing Strategy

### Unit Tests:

- **Window enumeration accuracy**: Verify `all_windows()` returns correct count and properties
- **Window ID consistency**: Ensure same window returns same ID across calls
- **Observer lifecycle**: Test observer creation, notification registration, and cleanup
- **Bundle ID retrieval**: Test bundle ID extraction for various application types
- **Window visibility detection**: Test visibility logic for minimized/hidden/normal windows

### Manual Testing Steps:

1. **Start GlazeWM with existing applications open** - verify immediate event reception
2. **Launch new applications** - verify observer registration and window event detection
3. **Minimize/restore windows** - verify correct event types and window state
4. **Move and resize windows** - verify position/size events and property updates
5. **Close applications** - verify observer cleanup and no zombie processes
6. **Extended operation** - run for hours to verify memory stability

## References

- Original incomplete implementation: `packages/wm-platform/src/platform_impl/macos/window_listener.rs`
- Windows reference implementation: `packages/wm-platform/src/platform_impl/windows/window_event_hook.rs`
- Error handling patterns: `packages/wm-platform/src/error.rs`
- Notification system: `packages/wm-platform/src/platform_impl/macos/classes/notification_center.rs`
- Cross-platform abstractions: `packages/wm-platform/src/platform_event.rs`
